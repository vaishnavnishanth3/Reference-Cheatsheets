================================================================================
        GITHUB ACTIONS WORKFLOW - COMPLETE STEP-BY-STEP GUIDE
================================================================================

TABLE OF CONTENTS
-----------------
1. Basics & Core Concepts
2. Workflow File Structure
3. Step-by-Step Learning Path
4. Behind the Scenes - How GitHub Actions Work
5. Common Workflow Examples
6. Best Practices
7. Troubleshooting
8. Official Documentation & Resources


================================================================================
1. BASICS & CORE CONCEPTS
================================================================================

What are GitHub Actions?
------------------------
GitHub Actions is a CI/CD platform that allows you to automate your build, 
test, and deployment pipeline. You can create workflows that build and test 
every pull request to your repository, or deploy merged pull requests to 
production.

Key Components:
---------------
â€¢ Workflows    - Automated processes defined in YAML files
â€¢ Events       - Specific activities that trigger a workflow
â€¢ Jobs         - Set of steps that execute on the same runner
â€¢ Steps        - Individual tasks that run commands or actions
â€¢ Actions      - Reusable units of code
â€¢ Runners      - Servers that run your workflows


AVAILABLE OPTIONS FOR EACH COMPONENT:
--------------------------------------

1. EVENTS (Trigger Options):
-----------------------------
Webhook Events:
  â€¢ push                    - Code pushed to repository
  â€¢ pull_request            - PR opened, synchronized, reopened
  â€¢ pull_request_target     - PR from fork (safer for secrets)
  â€¢ issues                  - Issue opened, edited, deleted, etc.
  â€¢ issue_comment           - Comment on issue or PR
  â€¢ create                  - Branch or tag created
  â€¢ delete                  - Branch or tag deleted
  â€¢ fork                    - Repository forked
  â€¢ watch                   - Repository starred
  â€¢ release                 - Release published, created, edited
  â€¢ deployment              - Deployment created
  â€¢ status                  - Commit status updated
  â€¢ check_run               - Check run completed
  â€¢ check_suite             - Check suite completed
  â€¢ workflow_run            - When another workflow completes
  â€¢ page_build              - GitHub Pages build triggered
  â€¢ discussion              - Discussion created or modified
  â€¢ discussion_comment      - Discussion comment created
  â€¢ gollum                  - Wiki page created or updated
  â€¢ milestone               - Milestone created, edited, etc.
  â€¢ project                 - Project created, updated, closed
  â€¢ repository_dispatch     - External webhook trigger
  
Manual Events:
  â€¢ workflow_dispatch       - Manual trigger from UI/API
  
Scheduled Events:
  â€¢ schedule                - Cron-based scheduling
    Example: cron: '30 5 * * 1-5'  (5:30 AM Mon-Fri)
    
Activity Types (for specific events):
  pull_request:
    - opened, synchronize, reopened, closed, assigned, unassigned
    - labeled, unlabeled, edited, ready_for_review, review_requested
    
  issues:
    - opened, edited, deleted, transferred, closed, reopened
    - assigned, unassigned, labeled, unlabeled


2. RUNNERS (runs-on Options):
------------------------------
GitHub-Hosted Runners:
  Ubuntu:
    â€¢ ubuntu-latest         (Currently Ubuntu 22.04)
    â€¢ ubuntu-22.04
    â€¢ ubuntu-20.04
    
  Windows:
    â€¢ windows-latest        (Currently Windows Server 2022)
    â€¢ windows-2022
    â€¢ windows-2019
    
  macOS:
    â€¢ macos-latest          (Currently macOS 14 Sonoma)
    â€¢ macos-14              (M1 chip - ARM64)
    â€¢ macos-13              (Intel chip)
    â€¢ macos-12              (Intel chip)
    â€¢ macos-11              (Intel chip)
    
  Self-Hosted:
    â€¢ self-hosted           - Your custom runner
    â€¢ [self-hosted, linux]  - With specific labels
    â€¢ [self-hosted, macOS, ARM64]  - Multiple labels


3. ACTIONS (uses: Options):
----------------------------
Official GitHub Actions:
  Repository Actions:
    â€¢ actions/checkout@v4              - Clone repository
    â€¢ actions/cache@v4                 - Cache dependencies
    â€¢ actions/upload-artifact@v4       - Upload build artifacts
    â€¢ actions/download-artifact@v4     - Download artifacts
    
  Setup Actions:
    â€¢ actions/setup-node@v4            - Setup Node.js
    â€¢ actions/setup-python@v5          - Setup Python
    â€¢ actions/setup-java@v4            - Setup Java
    â€¢ actions/setup-go@v5              - Setup Go
    â€¢ actions/setup-dotnet@v4          - Setup .NET
    
  Utility Actions:
    â€¢ actions/github-script@v7         - Run JavaScript
    â€¢ actions/create-release@v1        - Create GitHub release
    â€¢ actions/labeler@v5               - Auto-label PRs
    
  Third-Party Popular Actions:
    â€¢ docker/login-action@v3           - Docker Hub login
    â€¢ docker/build-push-action@v5      - Build Docker images
    â€¢ aws-actions/configure-aws-credentials@v4  - AWS setup
    â€¢ azure/login@v1                   - Azure login
    â€¢ google-github-actions/setup-gcloud@v1  - GCP setup
    â€¢ codecov/codecov-action@v4        - Upload coverage
    â€¢ softprops/action-gh-release@v1   - Create releases


4. STEP TYPES (What steps can do):
-----------------------------------
Run Shell Commands:
  â€¢ run: |                  - Multi-line shell commands
    Default shells: bash (Linux/macOS), pwsh (Windows)
    
Use Actions:
  â€¢ uses: owner/repo@version
    with:                   - Pass inputs to action
      key: value
    
Conditional Steps:
  â€¢ if: condition           - Execute conditionally
    Examples:
    - if: success()
    - if: failure()
    - if: always()
    - if: cancelled()
    - if: github.ref == 'refs/heads/main'


5. JOB CONFIGURATION OPTIONS:
------------------------------
Basic Options:
  â€¢ runs-on: runner         - Specify runner
  â€¢ needs: [job1, job2]     - Job dependencies
  â€¢ if: condition           - Conditional execution
  â€¢ timeout-minutes: 60     - Max execution time (default: 360)
  â€¢ continue-on-error: true - Don't fail workflow if job fails
  â€¢ container: image        - Run in Docker container
  
Strategy Options:
  â€¢ strategy:
      matrix:               - Matrix builds
        variable: [val1, val2]
      fail-fast: false      - Continue if one matrix job fails
      max-parallel: 2       - Limit concurrent jobs
      
Environment Options:
  â€¢ environment:
      name: production      - Deployment environment
      url: https://...      - Environment URL
      
Permissions:
  â€¢ permissions:
      contents: read        - Repository contents
      issues: write         - Issues and PRs
      pull-requests: write  - Pull requests
      actions: read         - GitHub Actions
      checks: write         - Checks API
      deployments: write    - Deployments
      packages: write       - GitHub Packages
      pages: write          - GitHub Pages
      statuses: write       - Commit statuses
      
Output Sharing:
  â€¢ outputs:
      output-name: ${{ steps.step-id.outputs.value }}


6. WORKFLOW-LEVEL OPTIONS:
---------------------------
Basic Settings:
  â€¢ name: "Workflow Name"   - Display name
  â€¢ run-name: "Run ${{ github.actor }}"  - Custom run name
  
Trigger Filters:
  â€¢ on:
      push:
        branches: [main, dev]           - Specific branches
        branches-ignore: [staging]      - Exclude branches
        tags: [v*]                      - Tag patterns
        paths: ['src/**']               - Specific paths
        paths-ignore: ['docs/**']       - Exclude paths
        
Concurrency Control:
  â€¢ concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true          - Cancel old runs
      
Defaults:
  â€¢ defaults:
      run:
        shell: bash                     - Default shell
        working-directory: ./src        - Default directory


7. ENVIRONMENT VARIABLES:
--------------------------
Predefined Variables:
  â€¢ GITHUB_ACTOR            - User triggering workflow
  â€¢ GITHUB_REPOSITORY       - Repo name (owner/repo)
  â€¢ GITHUB_SHA              - Commit SHA
  â€¢ GITHUB_WORKSPACE        - Workspace directory
  â€¢ RUNNER_OS               - OS (Linux, Windows, macOS)
  â€¢ RUNNER_TOOL_CACHE       - Tool cache directory
  
Custom Variables:
  â€¢ env:                    - Set at workflow/job/step level
      VAR_NAME: value
      
Configuration Variables:
  â€¢ vars.VARIABLE_NAME      - From repo/org settings

  
Secrets:
  â€¢ secrets.SECRET_NAME     - Encrypted secrets

8. CONTEXT OBJECTS:
-------------------
Available Contexts:
  â€¢ github.*                - Workflow run info
    - github.actor          - Triggering user
    - github.event_name     - Event type
    - github.ref            - Branch/tag
    - github.sha            - Commit hash
    - github.repository     - Repository name
    
  â€¢ env.*                   - Environment variables
  â€¢ job.*                   - Current job info
  â€¢ steps.*                 - Previous step outputs
  â€¢ runner.*                - Runner info
    - runner.os             - Operating system
    - runner.temp           - Temp path
  â€¢ secrets.*               - Secrets
  â€¢ vars.*                  - Config variables
  â€¢ matrix.*                - Matrix values
  â€¢ needs.*                 - Output from dependencies
  â€¢ inputs.*                - Workflow inputs


9. CONDITIONAL EXPRESSIONS:
----------------------------
Status Functions:
  â€¢ success()               - All previous steps succeeded
  â€¢ failure()               - Any previous step failed
  â€¢ always()                - Run regardless of status
  â€¢ cancelled()             - Workflow cancelled
  
  â€¢ ==, !=                  - Equality
  â€¢ <, <=, >, >=           - Comparison
  â€¢ &&, ||                  - Logical operators
  â€¢ !                       - Negation
  
Functions:
  â€¢ contains(search, item)  - String/array contains
  â€¢ startsWith(search, prefix)  - String starts with
  â€¢ endsWith(search, suffix)    - String ends with
  â€¢ format(string, ...)     - Format string
  â€¢ join(array, separator)  - Join array elements
  â€¢ toJSON(value)           - Convert to JSON
  â€¢ fromJSON(value)         - Parse JSON
  â€¢ hashFiles(pattern)      - Hash file contents


------------------------------
Artifact Actions:
  â€¢ actions/upload-artifact@v4
    with:
      path: path/to/files       - Files to upload
      retention-days: 90        - How long to keep (1-90)
      if-no-files-found: warn   - warn, error, ignore
      
    with:
      name: artifact-name       - Which artifact
      path: destination         - Where to download
      
  â€¢ actions/cache@v4
    with:
      path: ~/.cache            - Paths to cache
      key: ${{ runner.os }}-${{ hashFiles('**/lockfile') }}
      restore-keys: |           - Fallback keys


================================================================================
2. WORKFLOW FILE STRUCTURE
================================================================================

Location:
---------
â€¢ Workflows must be stored in: .github/workflows/
â€¢ Files must have .yml or .yaml extension
â€¢ Example: .github/workflows/ci.yml
Basic Anatomy:
--------------

name: Workflow Name                    # Optional but recommended
on: [push, pull_request]              # Trigger events
jobs:                                 # Jobs definition
  job-name:                           # Unique job identifier
    runs-on: ubuntu-latest            # Runner environment
    steps:                            # Steps to execute
        uses: actions/checkout@v4     # Use an action
      - name: Run Command             
        run: echo "Hello World"       # Run shell command


================================================================================
3. STEP-BY-STEP LEARNING PATH
================================================================================

LEVEL 1: HELLO WORLD WORKFLOW
------------------------------

Step 1: Create your first workflow file
File: .github/workflows/hello-world.yml

---
name: Hello World
on: [push]
jobs:
  greet:
    steps:
      - name: Say Hello
        run: echo "Hello, GitHub Actions!"
---

â€¢ Triggers on every push to any branch
â€¢ Runs on Ubuntu (latest version)
â€¢ Executes a simple echo command

Behind the scenes:
â€¢ Allocates a virtual machine (runner)
â€¢ Starts Ubuntu environment
â€¢ Executes the echo command
â€¢ Deallocates the runner


-------------------------------------
Step 2: Working with repository code
File: .github/workflows/test.yml

---
name: Run Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
          node-version: '20'
          
      - name: Install dependencies
        run: npm install
        
        run: npm test
---

What each step does:
1. Checkout code    - Clones your repository to the runner
3. Install deps     - Runs npm install in your project
4. Run tests        - Executes your test suite

Behind the scenes:
â€¢ Runner starts with fresh Ubuntu VM
â€¢ actions/checkout clones repo using git
â€¢ actions/setup-node downloads and configures Node.js
â€¢ Each 'run' command executes in a shell (bash by default)
â€¢ Working directory is the repository root


LEVEL 3: MULTIPLE JOBS WITH DEPENDENCIES
-----------------------------------------
Step 3: Job orchestration
File: .github/workflows/build-deploy.yml

---
name: Build and Deploy
on:
  push:
    branches: [main]
    
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build application
        run: npm run build
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-files
          path: dist/
          
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-files
          path: dist/
      - name: Run tests
        run: npm test
        
  deploy:
    runs-on: ubuntu-latest
    needs: [build, test]
    steps:
      - name: Deploy to production
        run: echo "Deploying..."
---

Key concepts:
â€¢ needs: [job]     - Creates job dependencies
â€¢ artifacts        - Share files between jobs
â€¢ Jobs run in parallel by default (unless needs specified)
Behind the scenes:
â€¢ GitHub Actions creates a dependency graph
â€¢ Build job runs first
â€¢ Artifacts are uploaded to GitHub's storage
â€¢ Test job waits for build to complete
â€¢ Test downloads artifacts from storage
â€¢ Deploy waits for both build and test
â€¢ Failed jobs prevent dependent jobs from running


LEVEL 4: ENVIRONMENT VARIABLES & SECRETS
-----------------------------------------

Step 4: Managing configuration
File: .github/workflows/advanced.yml

---
name: Advanced Workflow
on: [push]

env:
  GLOBAL_VAR: "I'm global"
jobs:
  use-variables:
    runs-on: ubuntu-latest
    env:
      JOB_VAR: "I'm job-scoped"
    steps:
      - name: Use environment variables
        env:
          STEP_VAR: "I'm step-scoped"
        run: |
          echo "Global: $GLOBAL_VAR"
          echo "Job: $JOB_VAR"
          echo "Step: $STEP_VAR"
          echo "GitHub context: ${{ github.repository }}"
      - name: Use secrets
        run: echo "Secret: ${{ secrets.MY_SECRET }}"
---

Variable scopes:
â€¢ Workflow level  - Available to all jobs
â€¢ Job level       - Available to all steps in job
â€¢ Step level      - Available only in that step

Behind the scenes:
â€¢ Variables are set as environment variables in the shell
â€¢ Secrets are stored encrypted in GitHub
â€¢ Secrets are decrypted at runtime and masked in logs
â€¢ Context expressions ${{ }} are evaluated before execution


LEVEL 5: MATRIX BUILDS
-----------------------

Step 5: Test across multiple versions
File: .github/workflows/matrix.yml

---
name: Matrix Build
on: [push]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [18, 20, 22]
        exclude:
          - os: macos-latest
            node-version: 18
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm test

Matrix strategy:
â€¢ Creates multiple jobs from combinations
â€¢ exclude: Remove specific combinations
â€¢ include: Add specific combinations
â€¢ max-parallel: Limit concurrent jobs

â€¢ GitHub creates 8 jobs (3 OS Ã— 3 versions - 1 excluded)
â€¢ Each job runs on its specified OS
â€¢ Jobs run in parallel (respecting concurrency limits)
â€¢ Matrix variables accessible via ${{ matrix.variable }}


LEVEL 6: CONDITIONAL EXECUTION
-------------------------------

Step 6: Control flow with conditions

---
name: Conditional Workflow
on: [push, pull_request]

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
      - name: Deploy to production
        run: echo "Deploying..."
        
  notify:
    runs-on: ubuntu-latest
    if: failure()
    needs: deploy
    steps:
      - name: Send notification
        run: echo "Build failed!"
        
  always-run:
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Cleanup
        run: echo "Running cleanup..."
---

Common conditions:
â€¢ success()          - Previous steps succeeded (default)
â€¢ failure()          - Previous step failed
â€¢ always()           - Run regardless of status
â€¢ cancelled()        - Workflow was cancelled
â€¢ github.ref == '...'- Branch/tag matching

Behind the scenes:
â€¢ Conditions evaluated before job/step starts
â€¢ Uses GitHub Actions expression syntax
â€¢ Context objects provide runtime information
â€¢ Skipped jobs/steps don't count as failures


================================================================================
4. BEHIND THE SCENES - HOW GITHUB ACTIONS WORK
================================================================================

Workflow Execution Flow:
------------------------

1. EVENT TRIGGER
   â””â”€> GitHub detects event (push, PR, schedule, etc.)
       â””â”€> Checks .github/workflows/ for matching workflows

2. WORKFLOW PARSING
   â””â”€> Parses YAML file
       â””â”€> Validates syntax and structure
           â””â”€> Creates execution plan with job dependencies

3. RUNNER ALLOCATION
   â””â”€> Requests runner from pool (GitHub-hosted or self-hosted)
       â””â”€> Spins up virtual machine with specified OS
           â””â”€> Pre-installs common tools and software

4. JOB EXECUTION
   â””â”€> Sets up environment variables and context
       â””â”€> Downloads actions from GitHub/marketplace
           â””â”€> Executes steps sequentially
               â””â”€> Each step runs in new shell process

5. ARTIFACT HANDLING
   â””â”€> Uploads artifacts to GitHub storage (90-day retention)
       â””â”€> Makes artifacts available to other jobs
           â””â”€> Can be downloaded from UI

6. CLEANUP
   â””â”€> Collects logs and results
       â””â”€> Deallocates runner
           â””â”€> Updates workflow status in UI

Runner Architecture:
--------------------

GitHub-Hosted Runners:
â€¢ Clean VM for each job
â€¢ Pre-installed software (see runner images documentation)
â€¢ 2-4 core CPUs, 7-14 GB RAM
â€¢ 14 GB SSD space
â€¢ Managed and maintained by GitHub
â€¢ Free minutes/month (varies by plan)

Self-Hosted Runners:
â€¢ Your own infrastructure
â€¢ Persistent between jobs (unless ephemeral)
â€¢ Custom software and configurations
â€¢ No usage limits
â€¢ You manage updates and security

Action Execution:
-----------------

When you use an action (uses: owner/repo@version):
1. GitHub downloads the action code
2. Action can be:
   â€¢ JavaScript action (runs in Node.js)
   â€¢ Docker container action (runs in container)
   â€¢ Composite action (combines multiple steps)
3. Action receives inputs via environment variables
4. Action produces outputs for subsequent steps

Contexts & Expressions:
-----------------------

Available contexts:
â€¢ github     - Workflow run information
â€¢ env        - Environment variables
â€¢ job        - Current job information
â€¢ steps      - Previous steps' outputs
â€¢ runner     - Runner information
â€¢ secrets    - Repository secrets
â€¢ vars       - Configuration variables
â€¢ matrix     - Matrix values
â€¢ needs      - Dependent job outputs
â€¢ inputs     - Workflow dispatch inputs

Expression syntax:
${{ <expression> }}
Example: ${{ github.actor }} - User who triggered workflow


DETAILED EXPLANATION & DIFFERENTIATION:
---------------------------------------

CONFIGURATION MANAGEMENT - env vs vars vs secrets:
---------------------------------------------------

1. ENV (Environment Variables)
   ----------------------------
   Purpose: Store runtime configuration and non-sensitive data
   
   When to use:
   â€¢ Temporary values needed during workflow execution
   â€¢ Values that change based on conditions
   â€¢ Non-sensitive data that can be visible in logs
   â€¢ Computed values from expressions
   
   Scope levels:
   â€¢ Workflow-level: Available to all jobs
   â€¢ Job-level: Available to all steps in job
   â€¢ Step-level: Available only to that step
   
   Example:
   ---
   env:
     NODE_VERSION: '20'              # Workflow level
     BUILD_ENV: production
   
   jobs:
     build:
       env:
         APP_NAME: myapp             # Job level
       steps:
         - name: Build
           env:
             BUILD_FLAGS: '--optimize'  # Step level
           run: |
             echo "Building $APP_NAME"
             echo "Node: $NODE_VERSION"
             npm run build $BUILD_FLAGS
   ---
   
   Characteristics:
   âœ“ Visible in workflow logs
   âœ“ Can be dynamically set during workflow
   âœ“ Can use expressions: ${{ github.ref }}
   âœ“ Overridden by narrower scope (step > job > workflow)
   âœ— Not encrypted
   âœ— Lost after workflow completes
   
   Access methods:
   â€¢ In run steps: $VARIABLE_NAME or ${VARIABLE_NAME}
   â€¢ In expressions: ${{ env.VARIABLE_NAME }}


2. VARS (Configuration Variables)
   -------------------------------
   Purpose: Store non-sensitive configuration across workflows
   
   When to use:
   â€¢ Configuration values shared across multiple workflows
   â€¢ Environment-specific settings (dev, staging, prod)
   â€¢ Values that rarely change
   â€¢ Non-sensitive data (URLs, usernames, flags)
   
   Setup location:
   â€¢ Repository Settings > Secrets and variables > Actions > Variables
   â€¢ Organization level (shared across repos)
   â€¢ Environment level (per deployment environment)
   
   Example:
   ---
   jobs:
     deploy:
       environment: production
       steps:
         - name: Deploy
           run: |
             echo "Deploying to ${{ vars.API_URL }}"
             echo "Region: ${{ vars.AWS_REGION }}"
             echo "Environment: ${{ vars.ENVIRONMENT_NAME }}"
   ---
   
   Characteristics:
   âœ“ Persistent across workflow runs
   âœ“ Centrally managed in UI
   âœ“ Can be scoped to environments
   âœ“ Visible in logs
   âœ“ No limit on number of variables
   âœ— Not encrypted (don't store sensitive data)
   âœ— Cannot be set during workflow execution
   
   Access: ${{ vars.VARIABLE_NAME }}
   
   Common use cases:
   â€¢ API endpoints: vars.API_BASE_URL
   â€¢ Feature flags: vars.ENABLE_FEATURE_X
   â€¢ Configuration: vars.MAX_RETRIES
   â€¢ Environment names: vars.ENV_NAME


3. SECRETS (Encrypted Secrets)
   ----------------------------
   Purpose: Store sensitive data securely
   
   When to use:
   â€¢ API keys, tokens, passwords
   â€¢ SSH keys, certificates
   â€¢ Database credentials
   â€¢ Any sensitive information
   
   Setup location:
   â€¢ Repository Settings > Secrets and variables > Actions > Secrets
   â€¢ Organization secrets (shared across repos)
   â€¢ Environment secrets (per deployment environment)
   
   Example:
   ---
   jobs:
     deploy:
       steps:
         - name: Deploy to AWS
           env:
             AWS_ACCESS_KEY: ${{ secrets.AWS_ACCESS_KEY_ID }}
             AWS_SECRET_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
           run: |
             aws configure set aws_access_key_id $AWS_ACCESS_KEY
             aws s3 sync ./build s3://my-bucket
   ---
   
   Characteristics:
   âœ“ Encrypted at rest using libsodium sealed boxes
   âœ“ Redacted (masked) in logs automatically
   âœ“ Can be scoped to environments with approvals
   âœ“ Can set expiration dates
   âœ— Cannot view value after creation (only update)
   âœ— Limited to 100 secrets per repository
   âœ— Max 64 KB per secret value
   
   Access: ${{ secrets.SECRET_NAME }}
   
   Security features:
   â€¢ Automatically masked in logs (shows ***)
   â€¢ Encrypted in transit and at rest
   â€¢ Audit logs for access
   â€¢ Can require reviewers for environment secrets
   
   Built-in secret:
   â€¢ GITHUB_TOKEN - Auto-generated for each workflow run
     Permissions: Read/write to repository, packages, etc.


COMPARISON TABLE: env vs vars vs secrets
-----------------------------------------
Feature          | env           | vars          | secrets
-----------------|---------------|---------------|------------------
Encryption       | No            | No            | Yes
Visibility       | In logs       | In logs       | Masked in logs
Persistence      | Workflow only | Permanent     | Permanent
Management       | In YAML       | In UI         | In UI
Sensitivity      | Non-sensitive | Non-sensitive | Sensitive only
Dynamic values   | Yes           | No            | No
Expressions      | Yes           | No            | No
Scope levels     | 3 (W/J/S)     | Repo/Org/Env  | Repo/Org/Env
Max count        | Unlimited     | Unlimited     | 100 per repo
Use case         | Runtime data  | Configuration | Credentials


MATRIX vs STRATEGY:
-------------------

STRATEGY (Parent Concept)
   Purpose: Define how jobs are executed (parallelization, error handling)
   
   Components of strategy:
   
   1. matrix - Create multiple job variations
   2. fail-fast - Stop all jobs if one fails (default: true)
   3. max-parallel - Limit concurrent jobs
   
   Example:
   ---
   strategy:
     fail-fast: false           # Continue even if one fails
     max-parallel: 3            # Run max 3 jobs at once
     matrix:                    # Create job variations
       os: [ubuntu, windows, macos]
       node: [18, 20]
   ---


MATRIX (Job Multiplication)
   Purpose: Create multiple job runs with different configurations
   
   When to use:
   â€¢ Test across multiple OS versions
   â€¢ Test with different language/runtime versions
   â€¢ Test with different configurations
   â€¢ Build for multiple platforms
   
   Basic matrix:
   ---
   strategy:
     matrix:
       os: [ubuntu-latest, windows-latest, macos-latest]
       node-version: [18, 20, 22]
   # Creates 9 jobs: 3 OS Ã— 3 Node versions
   
   runs-on: ${{ matrix.os }}
   steps:
     - uses: actions/setup-node@v4
       with:
         node-version: ${{ matrix.node-version }}
   ---
   
   Advanced matrix options:
   
   INCLUDE - Add specific combinations
   ---
   matrix:
     os: [ubuntu-latest, windows-latest]
     node: [18, 20]
     include:
       - os: macos-latest      # Add macOS with Node 20 only
         node: 20
       - os: ubuntu-latest     # Add experimental flag for specific combo
         node: 20
         experimental: true
   # Creates: 4 base + 2 included = 6 jobs
   ---
   
   EXCLUDE - Remove specific combinations
   ---
   matrix:
     os: [ubuntu-latest, windows-latest, macos-latest]
     node: [18, 20, 22]
     exclude:
       - os: macos-latest      # Don't test Node 18 on macOS
         node: 18
       - os: windows-latest    # Don't test Node 22 on Windows
         node: 22
   # Creates: 9 - 2 = 7 jobs
   ---
   
   Multiple variables:
   ---
   matrix:
     os: [ubuntu-latest, windows-latest]
     node: [18, 20]
     database: [mysql, postgres]
   # Creates: 2 OS Ã— 2 Node Ã— 2 DB = 8 jobs
   ---
   
   Accessing matrix values:
   â€¢ In expressions: ${{ matrix.variable }}
   â€¢ In environment: Set env var from matrix value
   
   Characteristics:
   âœ“ Jobs run in parallel (respecting max-parallel)
   âœ“ Each job gets fresh runner
   âœ“ Fast feedback across configurations
   âœ“ Can combine multiple dimensions
   âœ— Can consume many runner minutes
   âœ— Need to manage test data for parallel runs


MATRIX vs MANUAL JOBS:
----------------------

Without Matrix (Manual duplication):
---
jobs:
  test-ubuntu-18:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: 18
      - run: npm test
  
  test-ubuntu-20:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: npm test
  
  # ... repeat for each combination (error-prone!)
---

With Matrix (DRY principle):
---
jobs:
  test:
    strategy:
      matrix:
        node: [18, 20]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}
      - run: npm test
---


STRATEGY OPTIONS EXPLAINED:
----------------------------

fail-fast:
   Default: true
   Purpose: Control behavior when a matrix job fails
   
   fail-fast: true (default)
   â€¢ First failure cancels all running/pending jobs
   â€¢ Fast feedback, saves runner minutes
   â€¢ Good for: CI checks, quick validation
   
   fail-fast: false
   â€¢ All jobs run to completion regardless of failures
   â€¢ See all failures at once
   â€¢ Good for: Comprehensive testing, troubleshooting
   
   Example:
   ---
   strategy:
     fail-fast: false    # Test all combinations even if one fails
     matrix:
       os: [ubuntu, windows, macos]
   ---

max-parallel:
   Default: Unlimited (subject to runner availability)
   Purpose: Limit concurrent job execution
   
   Use cases:
   â€¢ Prevent overwhelming external services
   â€¢ Limit resource consumption
   â€¢ Control cost (for paid plans)
   â€¢ Prevent rate limiting
   
   Example:
   ---
   strategy:
     max-parallel: 2    # Run only 2 matrix jobs at once
     matrix:
       test-suite: [unit, integration, e2e, performance, security]
   # Instead of 5 parallel, runs 2 at a time
   ---


REAL-WORLD COMPARISON EXAMPLE:
-------------------------------

Scenario: Deploy to multiple environments with different configs

Bad approach (mixing concerns):
---
jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      API_KEY: "hardcoded-key"        # âŒ Sensitive in code
      API_URL: "https://api.dev.com"  # âŒ Not reusable
    steps:
      - run: echo "Deploying..."
---

Better approach (using all concepts correctly):
---
jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ matrix.environment }}
    strategy:
      fail-fast: false
      matrix:
        environment: [development, staging, production]
    env:
      DEPLOY_TIME: ${{ github.run_number }}      # Runtime value
      TRIGGERED_BY: ${{ github.actor }}          # Runtime value
    steps:
      - name: Deploy to ${{ matrix.environment }}
        env:
          # Secrets for sensitive data
          API_KEY: ${{ secrets.API_KEY }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          # Vars for configuration
          API_URL: ${{ vars.API_BASE_URL }}
          REGION: ${{ vars.AWS_REGION }}
          # Env for runtime data
          ENV_NAME: ${{ matrix.environment }}
        run: |
          echo "Deploying to $ENV_NAME"
          echo "API: $API_URL"
          echo "Region: $REGION"
          echo "Run: $DEPLOY_TIME by $TRIGGERED_BY"
          # API_KEY used but not displayed
---


DECISION TREE - WHAT TO USE WHEN:
----------------------------------

Need to store data?
  â”œâ”€> Sensitive (password, token, key)
  â”‚   â””â”€> Use SECRETS
  â”‚
  â”œâ”€> Configuration (URL, region, flags)
  â”‚   â”œâ”€> Same across workflows
  â”‚   â”‚   â””â”€> Use VARS
  â”‚   â””â”€> Changes during workflow
  â”‚       â””â”€> Use ENV
  â”‚
  â””â”€> Computed/Runtime value
      â””â”€> Use ENV

Need to test multiple configurations?
  â”œâ”€> Multiple OS/versions/configs
  â”‚   â””â”€> Use MATRIX
  â”‚
  â””â”€> Just one configuration
      â””â”€> Don't use matrix

Need to control job execution?
  â”œâ”€> Limit concurrent runs
  â”‚   â””â”€> Use max-parallel
  â”‚
  â””â”€> Stop on first failure
      â””â”€> Use fail-fast: true (default)


BEST PRACTICES SUMMARY:
-----------------------

ENV:
  âœ“ Use for temporary, workflow-specific values
  âœ“ Use for computed values from expressions
  âœ“ Use different scope levels appropriately
  âœ— Don't store sensitive data
  âœ— Don't use for persistent configuration

VARS:
  âœ“ Use for non-sensitive configuration
  âœ“ Use for values shared across workflows
  âœ“ Use environment-specific vars for different deploys
  âœ— Don't store secrets
  âœ— Don't use for runtime-computed values

SECRETS:
  âœ“ Use for all sensitive data
  âœ“ Use environment secrets for production
  âœ“ Rotate regularly
  âœ“ Use GITHUB_TOKEN when possible
  âœ— Never echo secrets in logs
  âœ— Don't store in environment variables unnecessarily

MATRIX:
  âœ“ Use for testing multiple configurations
  âœ“ Use include/exclude for precise control
  âœ“ Consider runner costs for large matrices
  âœ— Don't create overly large matrices
  âœ— Don't use if configurations are too different

STRATEGY:
  âœ“ Set fail-fast: false for comprehensive testing
  âœ“ Use max-parallel to control resource usage
  âœ“ Combine with matrix for powerful testing
  âœ— Don't ignore the default settings without reason


================================================================================
5. COMMON WORKFLOW EXAMPLES
================================================================================

Example 1: Node.js CI/CD
------------------------
---
name: Node.js CI
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18, 20, 22]
    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
      - run: npm ci
      - run: npm run build --if-present
      - run: npm test
---


Example 2: Python Testing
--------------------------
---
name: Python Tests
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.9', '3.10', '3.11', '3.12']
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run tests with pytest
        run: pytest
---


Example 3: Docker Build & Push
-------------------------------
---
name: Docker Build
on:
  push:
    branches: [main]

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
          
      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: user/app:latest
---


Example 4: Scheduled Workflow
------------------------------
---
name: Nightly Build
on:
  schedule:
    - cron: '0 2 * * *'  # Run at 2 AM UTC daily
  workflow_dispatch:     # Manual trigger option

jobs:
  nightly:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run nightly tests
        run: npm run test:e2e
---


Example 5: Manual Workflow with Inputs
---------------------------------------
---
name: Manual Deploy
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - development
          - staging
          - production
      version:
        description: 'Version to deploy'
        required: true
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy ${{ inputs.version }} to ${{ inputs.environment }}
        run: |
          echo "Deploying version ${{ inputs.version }}"
          echo "To environment ${{ inputs.environment }}"
---


================================================================================
6. BEST PRACTICES
================================================================================

1. Version Control
------------------
âœ“ Pin actions to specific versions or SHA
  uses: actions/checkout@v4           # Good
  uses: actions/checkout@8e5e7e5...   # Better (SHA)
âœ— Don't use @main or @master
  uses: actions/checkout@main         # Risky

2. Security
-----------
âœ“ Use secrets for sensitive data
âœ“ Limit scope of secrets (repository, environment, organization)
âœ“ Use GITHUB_TOKEN for API calls (auto-generated)
âœ“ Review third-party actions before using
âœ“ Enable required reviewers for deployments
âœ— Never echo secrets in logs
âœ— Don't commit credentials to repository

3. Performance
--------------
âœ“ Cache dependencies (npm, pip, maven, etc.)
âœ“ Use artifacts for large files between jobs
âœ“ Run jobs in parallel when possible
âœ“ Use matrix strategy for testing multiple versions
âœ“ Set appropriate timeout-minutes
âœ— Don't install unnecessary dependencies
âœ— Don't run expensive operations on every commit

4. Reliability
--------------
âœ“ Use if conditions to skip unnecessary jobs
âœ“ Set continue-on-error for non-critical steps
âœ“ Implement retry logic for flaky tests
âœ“ Use concurrency to cancel outdated runs
âœ— Don't rely on external services without error handling

5. Maintainability
------------------
âœ“ Use meaningful names for workflows, jobs, and steps
âœ“ Add comments to explain complex logic
âœ“ Use reusable workflows for common patterns
âœ“ Keep workflows DRY (Don't Repeat Yourself)
âœ“ Document required secrets in README
âœ— Don't create monolithic workflows

6. Caching Example
------------------
---
- name: Cache dependencies
  uses: actions/cache@v4
  with:
    path: ~/.npm
    key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
    restore-keys: |
      ${{ runner.os }}-node-
---


================================================================================
7. TROUBLESHOOTING
================================================================================

Common Issues & Solutions:
--------------------------

Issue: Workflow not triggering
Solution:
â€¢ Check YAML syntax (use YAML validator)
â€¢ Verify workflow file is in .github/workflows/
â€¢ Check event filters (branches, paths, etc.)
â€¢ Ensure repository has Actions enabled

Issue: Step fails with "command not found"
Solution:
â€¢ Add setup action (setup-node, setup-python, etc.)
â€¢ Install required dependencies
â€¢ Check runner OS compatibility

Issue: Permission denied
Solution:
â€¢ Add permissions to workflow or job level
â€¢ Use GITHUB_TOKEN with appropriate scopes
â€¢ Check repository settings for Actions permissions

Issue: Timeout
Solution:
â€¢ Add or increase timeout-minutes
â€¢ Optimize slow operations (caching, parallel jobs)
â€¢ Check for infinite loops or hanging processes

Issue: Cannot access secrets
Solution:
â€¢ Verify secret exists in repository settings
â€¢ Check secret name spelling (case-sensitive)
â€¢ Ensure workflow has access to environment secrets

Debugging Tips:
---------------
1. Enable debug logging:
   Set secrets: ACTIONS_RUNNER_DEBUG and ACTIONS_STEP_DEBUG to true

2. Use tmate for interactive debugging:
   - uses: mxschmitt/action-tmate@v3

3. Print context information:
   - run: echo '${{ toJSON(github) }}'

4. Check logs carefully:
   â€¢ Expand all log groups
   â€¢ Look for warning messages
   â€¢ Check exit codes


================================================================================
8. OFFICIAL DOCUMENTATION & RESOURCES
================================================================================

Official GitHub Documentation:
-------------------------------

Main Documentation:
https://docs.github.com/en/actions

Getting Started:
https://docs.github.com/en/actions/quickstart

Workflow Syntax:
https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions

Events that trigger workflows:
https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows

Contexts:
https://docs.github.com/en/actions/learn-github-actions/contexts

Expressions:
https://docs.github.com/en/actions/learn-github-actions/expressions

Environment variables:
https://docs.github.com/en/actions/learn-github-actions/environment-variables

Secrets:
https://docs.github.com/en/actions/security-guides/encrypted-secrets

GitHub Actions Marketplace:
https://github.com/marketplace?type=actions

Runner Images (Pre-installed software):
https://github.com/actions/runner-images

GitHub Actions Security:
https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions


Popular Official Actions:
-------------------------
â€¢ actions/checkout          - Check out repository
â€¢ actions/setup-node        - Setup Node.js
â€¢ actions/setup-python      - Setup Python
â€¢ actions/setup-java        - Setup Java
â€¢ actions/cache             - Cache dependencies
â€¢ actions/upload-artifact   - Upload artifacts
â€¢ actions/download-artifact - Download artifacts
â€¢ actions/github-script     - Run JavaScript with GitHub API


Community Resources:
--------------------

GitHub Actions Examples Repository:
https://github.com/actions/starter-workflows

Awesome GitHub Actions (Curated list):
https://github.com/sdras/awesome-actions

GitHub Actions Toolkit (For building actions):
https://github.com/actions/toolkit

GitHub Blog - Actions Category:
https://github.blog/tag/github-actions/


Interactive Learning:
---------------------

GitHub Skills:
https://skills.github.com/

GitHub Actions Hero:
https://github-actions-hero.vercel.app/

GitHub Actions Cheat Sheet:
https://github.github.io/actions-cheat-sheet/actions-cheat-sheet.html


Video Tutorials:
----------------

GitHub Actions Official Channel:
https://www.youtube.com/c/GitHub

GitHub Actions Tutorial Playlist:
https://www.youtube.com/playlist?list=PLArH6NjfKsUhvGHrpag7SuPumMzQRhUKY


API & Advanced:
---------------

GitHub Actions API:
https://docs.github.com/en/rest/actions

Creating Custom Actions:
https://docs.github.com/en/actions/creating-actions

Reusable Workflows:
https://docs.github.com/en/actions/using-workflows/reusing-workflows


================================================================================
QUICK REFERENCE - COMMON COMMANDS
================================================================================

Create workflow file:
$ mkdir -p .github/workflows
$ touch .github/workflows/ci.yml

Validate workflow locally (using act):
$ brew install act
$ act -l                    # List jobs
$ act push                  # Run push event locally

Monitor workflow runs:
$ gh run list               # List recent runs
$ gh run view               # View specific run
$ gh run watch              # Watch active run

Manage secrets:
$ gh secret set SECRET_NAME # Set secret
$ gh secret list            # List secrets

Trigger workflow manually:
$ gh workflow run workflow-name.yml


================================================================================
CONCLUSION
================================================================================

GitHub Actions provides powerful automation capabilities for your development
workflow. Start simple with basic workflows and gradually add complexity as 
you become more comfortable.

Key takeaways:
â€¢ Workflows are YAML files in .github/workflows/
â€¢ Events trigger workflows
â€¢ Jobs contain steps that run commands or actions
â€¢ Use the marketplace for pre-built actions
â€¢ Leverage caching and parallelization for performance
â€¢ Always use secrets for sensitive data
â€¢ Refer to official documentation for latest features

Happy automating! ðŸš€

================================================================================
Last Updated: November 2024
GitHub Actions Version: GitHub Enterprise 3.x compatible
================================================================================
